import"./modulepreload-polyfill-3cfb730f.js";import{G as Z}from"./lil-gui.esm-aba6213a.js";class O{static loadFile(t){return new Promise((i,s)=>{fetch(t).then(e=>e.text()).then(e=>{i(e)}).catch(e=>{s(e)})})}static createWebGLContext(t){const i=t.getContext("webgl");if(i==null)throw new Error("webgl not supported");return i}static createShaderObject(t,i,s){const e=t.createShader(s);if(t.shaderSource(e,i),t.compileShader(e),t.getShaderParameter(e,t.COMPILE_STATUS))return e;throw new Error(t.getShaderInfoLog(e))}static createProgramObject(t,i,s){const e=t.createProgram();if(t.attachShader(e,i),t.attachShader(e,s),t.linkProgram(e),t.deleteShader(i),t.deleteShader(s),t.getProgramParameter(e,t.LINK_STATUS))return t.useProgram(e),e;throw new Error(t.getProgramInfoLog(e))}static createVBO(t,i){const s=t.createBuffer();return t.bindBuffer(t.ARRAY_BUFFER,s),t.bufferData(t.ARRAY_BUFFER,new Float32Array(i),t.STATIC_DRAW),t.bindBuffer(t.ARRAY_BUFFER,null),s}static createIBO(t,i){const s=t.createBuffer();return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,s),t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Int16Array(i),t.STATIC_DRAW),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),s}static enableBuffer(t,i,s,e,n){for(let o=0;o<i.length;++o)t.bindBuffer(t.ARRAY_BUFFER,i[o]),t.enableVertexAttribArray(s[o]),t.vertexAttribPointer(s[o],e[o],t.FLOAT,!1,0,0);n!=null&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)}}class Y{static get Vec2(){return W}static get Vec3(){return Q}static get Mat4(){return $}static get Qtn(){return K}}let W=class _{static create(t=0,i=0){const s=new Float32Array(2);return s[0]=t,s[1]=i,s}static length(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1])}static normalize(t){const i=_.create(),s=_.length(t);if(s>0){const e=1/s;i[0]=t[0]*e,i[1]=t[1]*e}return i}static dot(t,i){return t[0]*i[0]+t[1]*i[1]}static cross(t,i){return _.create(),t[0]*i[1]-t[1]*i[0]}},Q=class G{static create(t=0,i=0,s=0){const e=new Float32Array(3);return e[0]=t,e[1]=i,e[2]=s,e}static length(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}static normalize(t){const i=G.create(),s=G.length(t);if(s>0){const e=1/s;i[0]=t[0]*e,i[1]=t[1]*e,i[2]=t[2]*e}return i}static dot(t,i){return t[0]*i[0]+t[1]*i[1]+t[2]*i[2]}static cross(t,i){return G.create(t[1]*i[2]-t[2]*i[1],t[2]*i[0]-t[0]*i[2],t[0]*i[1]-t[1]*i[0])}static faceNormal(t,i,s){const e=G.create(i[0]-t[0],i[1]-t[1],i[2]-t[2]),n=G.create(s[0]-t[0],s[1]-t[1],s[2]-t[2]),o=G.create(e[1]*n[2]-e[2]*n[1],e[2]*n[0]-e[0]*n[2],e[0]*n[1]-e[1]*n[0]);return G.normalize(o)}},$=class F{static create(){return new Float32Array(16)}static identity(t){const i=t??F.create();return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}static multiply(t,i,s){const e=s??F.create(),n=t[0],o=t[1],r=t[2],h=t[3],u=t[4],a=t[5],l=t[6],c=t[7],f=t[8],L=t[9],p=t[10],g=t[11],M=t[12],P=t[13],d=t[14],x=t[15],y=i[0],I=i[1],m=i[2],E=i[3],A=i[4],v=i[5],D=i[6],b=i[7],w=i[8],T=i[9],R=i[10],C=i[11],V=i[12],N=i[13],H=i[14],k=i[15];return e[0]=y*n+I*u+m*f+E*M,e[1]=y*o+I*a+m*L+E*P,e[2]=y*r+I*l+m*p+E*d,e[3]=y*h+I*c+m*g+E*x,e[4]=A*n+v*u+D*f+b*M,e[5]=A*o+v*a+D*L+b*P,e[6]=A*r+v*l+D*p+b*d,e[7]=A*h+v*c+D*g+b*x,e[8]=w*n+T*u+R*f+C*M,e[9]=w*o+T*a+R*L+C*P,e[10]=w*r+T*l+R*p+C*d,e[11]=w*h+T*c+R*g+C*x,e[12]=V*n+N*u+H*f+k*M,e[13]=V*o+N*a+H*L+k*P,e[14]=V*r+N*l+H*p+k*d,e[15]=V*h+N*c+H*g+k*x,e}static scale(t,i,s){const e=s??F.create();return e[0]=t[0]*i[0],e[1]=t[1]*i[0],e[2]=t[2]*i[0],e[3]=t[3]*i[0],e[4]=t[4]*i[1],e[5]=t[5]*i[1],e[6]=t[6]*i[1],e[7]=t[7]*i[1],e[8]=t[8]*i[2],e[9]=t[9]*i[2],e[10]=t[10]*i[2],e[11]=t[11]*i[2],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}static translate(t,i,s){const e=s??F.create();return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[0]*i[0]+t[4]*i[1]+t[8]*i[2]+t[12],e[13]=t[1]*i[0]+t[5]*i[1]+t[9]*i[2]+t[13],e[14]=t[2]*i[0]+t[6]*i[1]+t[10]*i[2]+t[14],e[15]=t[3]*i[0]+t[7]*i[1]+t[11]*i[2]+t[15],e}static rotate(t,i,s,e){let n=e??F.create();const o=Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]);if(!o)return null;let r=s[0],h=s[1],u=s[2];if(o!=1){const N=1/o;r*=N,h*=N,u*=N}const a=Math.sin(i),l=Math.cos(i),c=1-l,f=t[0],L=t[1],p=t[2],g=t[3],M=t[4],P=t[5],d=t[6],x=t[7],y=t[8],I=t[9],m=t[10],E=t[11],A=r*r*c+l,v=h*r*c+u*a,D=u*r*c-h*a,b=r*h*c-u*a,w=h*h*c+l,T=u*h*c+r*a,R=r*u*c+h*a,C=h*u*c-r*a,V=u*u*c+l;return i?t!=n&&(n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]):n=t,n[0]=f*A+M*v+y*D,n[1]=L*A+P*v+I*D,n[2]=p*A+d*v+m*D,n[3]=g*A+x*v+E*D,n[4]=f*b+M*w+y*T,n[5]=L*b+P*w+I*T,n[6]=p*b+d*w+m*T,n[7]=g*b+x*w+E*T,n[8]=f*R+M*C+y*V,n[9]=L*R+P*C+I*V,n[10]=p*R+d*C+m*V,n[11]=g*R+x*C+E*V,n}static lookAt(t,i,s,e){const n=e??F.create(),o=t[0],r=t[1],h=t[2],u=i[0],a=i[1],l=i[2],c=s[0],f=s[1],L=s[2];if(o==u&&r==a&&h==l)return F.identity(n);let p,g,M,P,d,x,y,I,m,E;return y=o-u,I=r-a,m=h-l,E=1/Math.sqrt(y*y+I*I+m*m),y*=E,I*=E,m*=E,p=f*m-L*I,g=L*y-c*m,M=c*I-f*y,E=Math.sqrt(p*p+g*g+M*M),E?(E=1/E,p*=E,g*=E,M*=E):(p=0,g=0,M=0),P=I*M-m*g,d=m*p-y*M,x=y*g-I*p,E=Math.sqrt(P*P+d*d+x*x),E?(E=1/E,P*=E,d*=E,x*=E):(P=0,d=0,x=0),n[0]=p,n[1]=P,n[2]=y,n[3]=0,n[4]=g,n[5]=d,n[6]=I,n[7]=0,n[8]=M,n[9]=x,n[10]=m,n[11]=0,n[12]=-(p*o+g*r+M*h),n[13]=-(P*o+d*r+x*h),n[14]=-(y*o+I*r+m*h),n[15]=1,n}static perspective(t,i,s,e,n){const o=n??F.create(),r=s*Math.tan(t*Math.PI/360),u=r*i*2,a=r*2,l=e-s;return o[0]=s*2/u,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=s*2/a,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=-(e+s)/l,o[11]=-1,o[12]=0,o[13]=0,o[14]=-(e*s*2)/l,o[15]=0,o}static ortho(t,i,s,e,n,o,r){const h=r??F.create(),u=i-t,a=s-e,l=o-n;return h[0]=2/u,h[1]=0,h[2]=0,h[3]=0,h[4]=0,h[5]=2/a,h[6]=0,h[7]=0,h[8]=0,h[9]=0,h[10]=-2/l,h[11]=0,h[12]=-(t+i)/u,h[13]=-(s+e)/a,h[14]=-(o+n)/l,h[15]=1,h}static transpose(t,i){const s=i??F.create();return s[0]=t[0],s[1]=t[4],s[2]=t[8],s[3]=t[12],s[4]=t[1],s[5]=t[5],s[6]=t[9],s[7]=t[13],s[8]=t[2],s[9]=t[6],s[10]=t[10],s[11]=t[14],s[12]=t[3],s[13]=t[7],s[14]=t[11],s[15]=t[15],s}static inverse(t,i){const s=i??F.create(),e=t[0],n=t[1],o=t[2],r=t[3],h=t[4],u=t[5],a=t[6],l=t[7],c=t[8],f=t[9],L=t[10],p=t[11],g=t[12],M=t[13],P=t[14],d=t[15],x=e*u-n*h,y=e*a-o*h,I=e*l-r*h,m=n*a-o*u,E=n*l-r*u,A=o*l-r*a,v=c*M-f*g,D=c*P-L*g,b=c*d-p*g,w=f*P-L*M,T=f*d-p*M,R=L*d-p*P,C=1/(x*R-y*T+I*w+m*b-E*D+A*v);return s[0]=(u*R-a*T+l*w)*C,s[1]=(-n*R+o*T-r*w)*C,s[2]=(M*A-P*E+d*m)*C,s[3]=(-f*A+L*E-p*m)*C,s[4]=(-h*R+a*b-l*D)*C,s[5]=(e*R-o*b+r*D)*C,s[6]=(-g*A+P*I-d*y)*C,s[7]=(c*A-L*I+p*y)*C,s[8]=(h*T-u*b+l*v)*C,s[9]=(-e*T+n*b-r*v)*C,s[10]=(g*E-M*I+d*x)*C,s[11]=(-c*E+f*I-p*x)*C,s[12]=(-h*w+u*D-a*v)*C,s[13]=(e*w-n*D+o*v)*C,s[14]=(-g*m+M*y-P*x)*C,s[15]=(c*m-f*y+L*x)*C,s}static toVecIV(t,i){const s=t[0],e=t[1],n=t[2],o=t[3],r=t[4],h=t[5],u=t[6],a=t[7],l=t[8],c=t[9],f=t[10],L=t[11],p=t[12],g=t[13],M=t[14],P=t[15],d=i[0],x=i[1],y=i[2],I=i[3],m=new Float32Array(4);return m[0]=d*s+x*r+y*l+I*p,m[1]=d*e+x*h+y*c+I*g,m[2]=d*n+x*u+y*f+I*M,m[3]=d*o+x*a+y*L+I*P,m}static screenPositionFromMvp(t,i,s,e){const n=s*.5,o=e*.5,r=F.toVecIV(t,[i[0],i[1],i[2],1]);if(r[3]<=0)return[NaN,NaN];r[0]/=r[3],r[1]/=r[3],r[2]/=r[3];const h=W.create();return h[0]=n+r[0]*n,h[1]=o-r[1]*o,h}},K=class z{static create(){return new Float32Array(4)}static identity(t){const i=t??z.create();return i[0]=0,i[1]=0,i[2]=0,i[3]=1,i}static inverse(t,i){const s=i??z.create();return s[0]=-t[0],s[1]=-t[1],s[2]=-t[2],s[3]=t[3],s}static normalize(t){const i=z.create(),s=t[0],e=t[1],n=t[2],o=Math.sqrt(s*s+e*e+n*n);if(o>0){const r=1/o;i[0]=s*r,i[1]=e*r,i[2]=n*r}return i}static multiply(t,i,s){const e=s??z.create(),n=t[0],o=t[1],r=t[2],h=t[3],u=i[0],a=i[1],l=i[2],c=i[3];return e[0]=n*c+h*u+o*l-r*a,e[1]=o*c+h*a+r*u-n*l,e[2]=r*c+h*l+n*a-o*u,e[3]=h*c-n*u-o*a-r*l,e}static rotate(t,i,s){const e=s??z.create();let n=i[0],o=i[1],r=i[2];const h=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]);if(h!==0){const a=1/h;n*=a,o*=a,r*=a}const u=Math.sin(t*.5);return e[0]=n*u,e[1]=o*u,e[2]=r*u,e[3]=Math.cos(t*.5),e}static toVecIII(t,i,s){const e=s??Q.create(),n=z.create(),o=z.create(),r=z.create();return z.inverse(i,r),n[0]=t[0],n[1]=t[1],n[2]=t[2],z.multiply(r,n,o),z.multiply(o,i,r),e[0]=r[0],e[1]=r[1],e[2]=r[2],e}static toMatIV(t,i){const s=i??$.create(),e=t[0],n=t[1],o=t[2],r=t[3],h=e+e,u=n+n,a=o+o,l=e*h,c=e*u,f=e*a,L=n*u,p=n*a,g=o*a,M=r*h,P=r*u,d=r*a;return s[0]=1-(L+g),s[1]=c-d,s[2]=f+P,s[3]=0,s[4]=c+d,s[5]=1-(l+g),s[6]=p-M,s[7]=0,s[8]=f-P,s[9]=p+M,s[10]=1-(l+L),s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,s}static slerp(t,i,s,e){const n=e??z.create(),o=t[0]*i[0]+t[1]*i[1]+t[2]*i[2]+t[3]*i[3];let r=1-o*o;if(r<=0)n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3];else if(r=Math.sqrt(r),Math.abs(r)<1e-4)n[0]=t[0]*.5+i[0]*.5,n[1]=t[1]*.5+i[1]*.5,n[2]=t[2]*.5+i[2]*.5,n[3]=t[3]*.5+i[3]*.5;else{const h=Math.acos(o),u=h*s,a=Math.sin(h-u)/r,l=Math.sin(u)/r;n[0]=t[0]*a+i[0]*l,n[1]=t[1]*a+i[1]*l,n[2]=t[2]*a+i[2]*l,n[3]=t[3]*a+i[3]*l}return n}};class J{static plane(t,i,s){const e=t/2,n=i/2,o=[-e,n,0,e,n,0,-e,-n,0,e,-n,0],r=[0,0,1,0,0,1,0,0,1,0,0,1],h=[s[0],s[1],s[2],s[3],s[0],s[1],s[2],s[3],s[0],s[1],s[2],s[3],s[0],s[1],s[2],s[3]];return{position:o,normal:r,color:h,texCoord:[0,0,1,0,0,1,1,1],index:[0,2,1,1,2,3]}}static circle(t,i,s){const e=[],n=[],o=[],r=[],h=[];e.push(0,0,0),n.push(0,0,1),o.push(s[0],s[1],s[2],s[3]),r.push(.5,.5);let u=0;for(let a=0;a<t;a++){const l=Math.PI*2/t*a,c=Math.cos(l),f=Math.sin(l);e.push(c*i,f*i,0),n.push(0,0,1),o.push(s[0],s[1],s[2],s[3]),r.push((c+1)*.5,1-(f+1)*.5),a===t-1?h.push(0,u+1,1):h.push(0,u+1,u+2),++u}return{position:e,normal:n,color:o,texCoord:r,index:h}}static cube(t,i){const s=t*.5,e=[-s,-s,s,s,-s,s,s,s,s,-s,s,s,-s,-s,-s,-s,s,-s,s,s,-s,s,-s,-s,-s,s,-s,-s,s,s,s,s,s,s,s,-s,-s,-s,-s,s,-s,-s,s,-s,s,-s,-s,s,s,-s,-s,s,s,-s,s,s,s,s,-s,s,-s,-s,-s,-s,-s,s,-s,s,s,-s,s,-s],n=1/Math.sqrt(3),o=[-n,-n,n,n,-n,n,n,n,n,-n,n,n,-n,-n,-n,-n,n,-n,n,n,-n,n,-n,-n,-n,n,-n,-n,n,n,n,n,n,n,n,-n,-n,-n,-n,n,-n,-n,n,-n,n,-n,-n,n,n,-n,-n,n,n,-n,n,n,n,n,-n,n,-n,-n,-n,-n,-n,n,-n,n,n,-n,n,-n],r=[];for(let a=0;a<e.length/3;a++)r.push(i[0],i[1],i[2],i[3]);return{position:e,normal:o,color:r,texCoord:[0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1],index:[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]}}static cone(t,i,s,e){const n=[],o=[],r=[],h=[],u=[],a=s/2;n.push(0,-a,0),o.push(0,-1,0),r.push(e[0],e[1],e[2],e[3]),h.push(.5,.5);let l=0;for(let c=0;c<=t;c++){const f=Math.PI*2/t*c,L=Math.cos(f),p=Math.sin(f);n.push(L*i,-a,p*i,L*i,-a,p*i),o.push(0,-1,0,L,0,p),r.push(e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3]),h.push((L+1)*.5,1-(p+1)*.5,(L+1)*.5,1-(p+1)*.5),c!==t&&(u.push(0,l+1,l+3),u.push(l+4,l+2,t*2+3)),l+=2}return n.push(0,a,0),o.push(0,1,0),r.push(e[0],e[1],e[2],e[3]),h.push(.5,.5),{position:n,normal:o,color:r,texCoord:h,index:u}}static cylinder(t,i,s,e,n){const o=[],r=[],h=[],u=[],a=[],l=e/2;o.push(0,l,0,0,-l,0),r.push(0,1,0,0,-1,0),h.push(n[0],n[1],n[2],n[3],n[0],n[1],n[2],n[3]),u.push(.5,.5,.5,.5);let c=2;for(let f=0;f<=t;f++){const L=Math.PI*2/t*f,p=Math.cos(L),g=Math.sin(L);o.push(p*i,l,g*i,p*i,l,g*i,p*s,-l,g*s,p*s,-l,g*s),r.push(0,1,0,p,0,g,0,-1,0,p,0,g),h.push(n[0],n[1],n[2],n[3],n[0],n[1],n[2],n[3],n[0],n[1],n[2],n[3],n[0],n[1],n[2],n[3]),u.push((p+1)*.5,1-(g+1)*.5,1-f/t,0,(p+1)*.5,1-(g+1)*.5,1-f/t,1),f!==t&&a.push(0,c+4,c,1,c+2,c+6,c+5,c+7,c+1,c+1,c+7,c+3),c+=4}return{position:o,normal:r,color:h,texCoord:u,index:a}}static sphere(t,i,s,e){const n=[],o=[],r=[],h=[],u=[];for(let a=0;a<=t;a++){const l=Math.PI/t*a,c=Math.cos(l),f=Math.sin(l);for(let L=0;L<=i;L++){const p=Math.PI*2/i*L,g=f*s*Math.cos(p),M=c*s,P=f*s*Math.sin(p),d=f*Math.cos(p),x=f*Math.sin(p);n.push(g,M,P),o.push(d,c,x),r.push(e[0],e[1],e[2],e[3]),h.push(1-1/i*L,1/t*a)}}for(let a=0;a<t;a++)for(let l=0;l<i;l++){const c=(i+1)*a+l;u.push(c,c+1,c+i+2),u.push(c,c+i+2,c+i+1)}return{position:n,normal:o,color:r,texCoord:h,index:u}}static torus(t,i,s,e,n){const o=[],r=[],h=[],u=[],a=[];for(let l=0;l<=t;l++){const c=Math.PI*2/t*l,f=Math.cos(c),L=Math.sin(c);for(let p=0;p<=i;p++){const g=Math.PI*2/i*p,M=(f*s+e)*Math.cos(g),P=L*s,d=(f*s+e)*Math.sin(g),x=f*Math.cos(g),y=f*Math.sin(g),I=1/i*p;let m=1/t*l+.5;m>1&&(m-=1),m=1-m,o.push(M,P,d),r.push(x,L,y),h.push(n[0],n[1],n[2],n[3]),u.push(I,m)}}for(let l=0;l<t;l++)for(let c=0;c<i;c++){const f=(i+1)*l+c;a.push(f,f+i+1,f+1),a.push(f+i+1,f+i+2,f+1)}return{position:o,normal:r,color:h,texCoord:u,index:a}}static icosahedron(t,i){const s=(1+Math.sqrt(5))/2,e=s*t,n=Math.sqrt(1+s*s),o=[1/n,s/n],r=[-t,e,0,t,e,0,-t,-e,0,t,-e,0,0,-t,e,0,t,e,0,-t,-e,0,t,-e,e,0,-t,e,0,t,-e,0,-t,-e,0,t],h=[-o[0],o[1],0,o[0],o[1],0,-o[0],-o[1],0,o[0],-o[1],0,0,-o[0],o[1],0,o[0],o[1],0,-o[0],-o[1],0,o[0],-o[1],o[1],0,-o[0],o[1],0,o[0],-o[1],0,-o[0],-o[1],0,o[0]],u=[i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3]],a=[];for(let c=0,f=h.length;c<f;c+=3){const L=(Math.atan2(h[c+2],-h[c])+Math.PI)/(Math.PI*2),p=1-(h[c+1]+1)/2;a.push(L,p)}return{position:r,normal:h,color:u,texCoord:a,index:[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}}}const X=Y.Vec2,U=Y.Vec3,q=Y.Mat4,S=Y.Qtn;class j{static get DEFAULT_DISTANCE(){return 5}static get DEFAULT_MIN_DISTANCE(){return 1}static get DEFAULT_MAX_DISTANCE(){return 10}static get DEFAULT_MOVE_SCALE(){return 2}constructor(t,i={}){this.target=t,this.distance=i.distance||j.DEFAULT_DISTANCE,this.minDistance=i.min||j.DEFAULT_MIN_DISTANCE,this.maxDistance=i.max||j.DEFAULT_MAX_DISTANCE,this.moveScale=i.move||j.DEFAULT_MOVE_SCALE,this.position=U.create(0,0,this.distance),this.center=U.create(0,0,0),this.upDirection=U.create(0,1,0),this.defaultPosition=U.create(0,0,this.distance),this.defaultCenter=U.create(0,0,0),this.defaultUpDirection=U.create(0,1,0),this.movePosition=U.create(0,0,0),this.rotateX=0,this.rotateY=0,this.scale=0,this.isDown=!1,this.prevPosition=X.create(0,0),this.offsetPosition=X.create(0,0),this.qt=S.create(),this.qtx=S.create(),this.qty=S.create(),this.mouseInteractionStart=this.mouseInteractionStart.bind(this),this.mouseInteractionMove=this.mouseInteractionMove.bind(this),this.mouseInteractionEnd=this.mouseInteractionEnd.bind(this),this.wheelScroll=this.wheelScroll.bind(this),this.target.addEventListener("mousedown",this.mouseInteractionStart,!1),this.target.addEventListener("mousemove",this.mouseInteractionMove,!1),this.target.addEventListener("mouseup",this.mouseInteractionEnd,!1),this.target.addEventListener("wheel",this.wheelScroll,!1),this.target.addEventListener("contextmenu",s=>{s.preventDefault()},!1)}setPosition(t){this.defaultPosition=t}mouseInteractionStart(t){this.isDown=!0;const i=this.target.getBoundingClientRect();this.prevPosition=X.create(t.clientX-i.left,t.clientY-i.top)}mouseInteractionMove(t){if(this.isDown!==!0)return;const i=this.target.getBoundingClientRect(),s=i.width,e=i.height,n=t.clientX-i.left,o=t.clientY-i.top,r=1/Math.min(s,e);switch(this.offsetPosition=X.create(n-this.prevPosition[0],o-this.prevPosition[1]),this.prevPosition=X.create(n,o),t.buttons){case 1:this.rotateX+=this.offsetPosition[0]*r,this.rotateY+=this.offsetPosition[1]*r,this.rotateX=this.rotateX%1,this.rotateY=Math.min(Math.max(this.rotateY%1,-.25),.25);break;case 2:const h=U.create(this.offsetPosition[0],-this.offsetPosition[1],0),u=S.toVecIII(h,this.qt);this.movePosition[0]-=u[0]*r*this.moveScale,this.movePosition[1]-=u[1]*r*this.moveScale,this.movePosition[2]-=u[2]*r*this.moveScale;break}}mouseInteractionEnd(t){this.isDown=!1}wheelScroll(t){const i=t.wheelDelta;i>0?this.scale=-.5:i<0&&(this.scale=.5)}update(){const t=Math.PI*2,i=U.create(1,0,0),s=U.create(0,1,0);return this.scale*=.7,this.distance+=this.scale,this.distance=Math.min(Math.max(this.distance,this.minDistance),this.maxDistance),this.defaultPosition[2]=this.distance,S.identity(this.qt),S.identity(this.qtx),S.identity(this.qty),S.rotate(this.rotateX*t,s,this.qtx),S.toVecIII(i,this.qtx,i),S.rotate(this.rotateY*t,i,this.qty),S.multiply(this.qtx,this.qty,this.qt),S.toVecIII(this.defaultPosition,this.qt,this.position),S.toVecIII(this.defaultUpDirection,this.qt,this.upDirection),this.position[0]+=this.movePosition[0],this.position[1]+=this.movePosition[1],this.position[2]+=this.movePosition[2],this.center[0]=this.defaultCenter[0]+this.movePosition[0],this.center[1]=this.defaultCenter[1]+this.movePosition[1],this.center[2]=this.defaultCenter[2]+this.movePosition[2],q.lookAt(this.position,this.center,this.upDirection)}}var tt=`attribute vec3 position;
attribute vec3 normal;
attribute vec4 color;

uniform mat4 mMatrix;
uniform mat4 mvpMatrix;

varying vec4 vColor;
varying vec3 vNormal;
varying vec3 vPosition;

void main() {
    vNormal = normal;
    vPosition = (mMatrix * vec4(position, 1.0)).xyz;

    vColor = color;

    gl_Position = mvpMatrix * vec4(position, 1.0);
}`,it=`precision mediump float;

uniform float intensity;
uniform float isDirectionalLight;
uniform vec3 directionalLightColor;
uniform vec3 pointLightPosition1;
uniform vec3 pointLightColor1;
uniform vec3 spotLightPosition;
uniform vec3 spotLightTarget;
uniform vec3 spotLightColor;
uniform float innerLimit;
uniform float outerLimit;
uniform mat4 normalMatrix;

varying vec4 vColor;
varying vec3 vNormal;
varying vec3 vPosition;

const vec3 light = vec3(1.0, 1.0, 1.0);

void main() {
    vec3 n = (normalMatrix * vec4(vNormal, 0.0)).xyz;
    float d = dot(normalize(n), normalize(light));

    vec3 pointLightDirection = pointLightPosition1 - vPosition;
    float pd = clamp(dot(normalize(n), normalize(pointLightDirection)), 0.0, 1.0);

    vec3 spotLightDirection = spotLightPosition - vPosition;
    vec3 spotDirection = spotLightTarget - spotLightPosition;
    float spotEffect = dot(normalize(spotLightDirection), normalize(-spotDirection));
    float inLight = smoothstep(outerLimit, innerLimit, spotEffect);
    float sd = inLight * clamp(dot(normalize(n), normalize(spotLightDirection)), 0.0, 1.0);

    vec3 ambient = isDirectionalLight * vec3(0.1, 0.1, 0.1);

    vec3 combinedLight = d * directionalLightColor * intensity + pd * pointLightColor1 + sd * spotLightColor + ambient;

    gl_FragColor = vec4(vColor.rgb * combinedLight, vColor.a);
}`;window.addEventListener("DOMContentLoaded",()=>{const B=new st;B.init(),B.load().then(()=>{B.setupGeometry(),B.setupLocation(),B.start()})},!1);class st{constructor(){this.canvas=null,this.gl=null,this.program=null,this.attributeLocation=null,this.attributeStride=null,this.uniformLocation=null,this.torusGeometry=null,this.torusVBO=null,this.torusIBO=null,this.sphereGeometry=null,this.sphereVBO=null,this.sphereIBO=null,this.startTime=null,this.camera=null,this.isRender=!1,this.isTorusRotation=!1,this.isDirectionalLight=!0,this.directionalLightColor=[1,1,1],this.intensity=.5,this.isPointLight1=!1,this.isPointLightRotation1=!1,this.pointLightColor1=[1,0,0],this.isSpotLight=!1,this.isSpotLightTargetRotation=!1,this.spotLightPosition={x:0,y:2,z:0},this.spotLightColor=[0,0,1],this.innerLimit=10,this.outerLimit=20,this.resize=this.resize.bind(this),this.render=this.render.bind(this)}setCulling(t){const i=this.gl;i!=null&&(t===!0?i.enable(i.CULL_FACE):i.disable(i.CULL_FACE))}setDepthTest(t){const i=this.gl;i!=null&&(t===!0?i.enable(i.DEPTH_TEST):i.disable(i.DEPTH_TEST))}setRotation(t){this.isTorusRotation=t}init(){this.canvas=document.getElementById("webgl-canvas"),this.gl=O.createWebGLContext(this.canvas);const t=Y.Vec3,i={distance:4,min:1,max:10,move:2};this.camera=new j(this.canvas,i),this.camera.setPosition(t.create(0,3,i.distance)),this.resize(),window.addEventListener("resize",this.resize,!1),this.gl.enable(this.gl.CULL_FACE),this.gl.enable(this.gl.DEPTH_TEST);const s=new Z;s.add(this,"isTorusRotation").name("Rotation");const e=s.addFolder("Directional Light");e.add(this,"isDirectionalLight").name("On/Off").onChange(r=>{r?this.intensity=.5:this.intensity=0}),e.addColor(this,"directionalLightColor").name("Color"),e.add(this,"intensity",0,1).name("Intensity").onChange(r=>{this.isDirectionalLight?this.intensity=r:this.intensity=0});const n=s.addFolder("Point Light");n.add(this,"isPointLight1").name("On/Off"),n.add(this,"isPointLightRotation1").name("Rotation");const o=s.addFolder("Spot Light");o.add(this,"isSpotLight").name("On/Off"),o.add(this,"isSpotLightTargetRotation").name("Rotation"),o.add(this,"innerLimit",1,90),o.add(this,"outerLimit",1,90)}resize(){this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight}load(){return new Promise((t,i)=>{const s=this.gl;if(s==null){const e=new Error("not initialized");i(e)}else{let e=O.createShaderObject(s,tt,s.VERTEX_SHADER),n=O.createShaderObject(s,it,s.FRAGMENT_SHADER);this.program=O.createProgramObject(s,e,n),t()}})}setupGeometry(){const n=[1,1,1,1];this.torusGeometry=J.torus(32,32,.4,.8,n),this.torusVBO=[O.createVBO(this.gl,this.torusGeometry.position),O.createVBO(this.gl,this.torusGeometry.normal),O.createVBO(this.gl,this.torusGeometry.color)],this.torusIBO=O.createIBO(this.gl,this.torusGeometry.index)}setupLocation(){const t=this.gl;this.attributeLocation=[t.getAttribLocation(this.program,"position"),t.getAttribLocation(this.program,"normal"),t.getAttribLocation(this.program,"color")],this.attributeStride=[3,3,4],this.uniformLocation={mMatrix:t.getUniformLocation(this.program,"mMatrix"),mvpMatrix:t.getUniformLocation(this.program,"mvpMatrix"),normalMatrix:t.getUniformLocation(this.program,"normalMatrix"),isDirectionalLight:t.getUniformLocation(this.program,"isDirectionalLight"),pointLightPosition1:t.getUniformLocation(this.program,"pointLightPosition1"),intensity:t.getUniformLocation(this.program,"intensity"),pointLightPosition2:t.getUniformLocation(this.program,"pointLightPosition2"),spotLightPosition:t.getUniformLocation(this.program,"spotLightPosition"),spotLightTarget:t.getUniformLocation(this.program,"spotLightTarget"),directionalLightColor:t.getUniformLocation(this.program,"directionalLightColor"),pointLightColor1:t.getUniformLocation(this.program,"pointLightColor1"),spotLightColor:t.getUniformLocation(this.program,"spotLightColor"),innerLimit:t.getUniformLocation(this.program,"innerLimit"),outerLimit:t.getUniformLocation(this.program,"outerLimit")}}setupRendering(){const t=this.gl;t.viewport(0,0,this.canvas.width,this.canvas.height),t.clearColor(0,0,0,1),t.clearDepth(1),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT)}start(){this.startTime=Date.now(),this.isRender=!0,this.render()}stop(){this.isRender=!1}render(){const t=this.gl,i=Y.Mat4,s=Y.Vec3;this.isRender===!0&&requestAnimationFrame(this.render),this.isPointLight1?this.pointLightColor1=[1,0,0]:this.pointLightColor1=[0,0,0],this.isSpotLight?this.spotLightColor=[0,0,1]:this.spotLightColor=[0,0,0];const e=(Date.now()-this.startTime)*.001;this.setupRendering();const n=s.create(0,1,0),o=this.isTorusRotation===!0?i.rotate(i.identity(),e,n):i.identity(),r=this.camera.update(),h=45,u=window.innerWidth/window.innerHeight,a=.1,l=10,c=i.perspective(h,u,a,l),f=i.multiply(c,r),L=i.multiply(f,o),p=i.transpose(i.inverse(o)),g=this.isPointLightRotation1?s.create(Math.sin(e)*2,Math.cos(e)*2,1):s.create(3,2,1),M=s.create(this.spotLightPosition.x,this.spotLightPosition.y,this.spotLightPosition.z),P=this.isSpotLightTargetRotation?s.create(Math.cos(e),0,Math.sin(e)):s.create(1,0,0),d=this.innerLimit*Math.PI/180,x=this.outerLimit*Math.PI/180,y=this.isDirectionalLight?1:0;t.useProgram(this.program),t.uniformMatrix4fv(this.uniformLocation.mvpMatrix,!1,L),t.uniformMatrix4fv(this.uniformLocation.mMatrix,!1,o),t.uniformMatrix4fv(this.uniformLocation.normalMatrix,!1,p),t.uniform1f(this.uniformLocation.isDirectionalLight,y),t.uniform1f(this.uniformLocation.intensity,this.intensity),t.uniform3fv(this.uniformLocation.pointLightPosition1,g),t.uniform3fv(this.uniformLocation.spotLightPosition,M),t.uniform3fv(this.uniformLocation.spotLightTarget,P),t.uniform3fv(this.uniformLocation.directionalLightColor,this.directionalLightColor),t.uniform3fv(this.uniformLocation.pointLightColor1,this.pointLightColor1),t.uniform3fv(this.uniformLocation.spotLightColor,this.spotLightColor),t.uniform1f(this.uniformLocation.innerLimit,Math.cos(d)),t.uniform1f(this.uniformLocation.outerLimit,Math.cos(x)),O.enableBuffer(t,this.torusVBO,this.attributeLocation,this.attributeStride,this.torusIBO),t.drawElements(t.TRIANGLES,this.torusGeometry.index.length,t.UNSIGNED_SHORT,0)}}
