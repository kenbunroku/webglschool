import"./modulepreload-polyfill-3cfb730f.js";import{G as Z}from"./lil-gui.esm-aba6213a.js";class O{static loadFile(t){return new Promise((i,s)=>{fetch(t).then(n=>n.text()).then(n=>{i(n)}).catch(n=>{s(n)})})}static createWebGLContext(t){const i=t.getContext("webgl");if(i==null)throw new Error("webgl not supported");return i}static createShaderObject(t,i,s){const n=t.createShader(s);if(t.shaderSource(n,i),t.compileShader(n),t.getShaderParameter(n,t.COMPILE_STATUS))return n;throw new Error(t.getShaderInfoLog(n))}static createProgramObject(t,i,s){const n=t.createProgram();if(t.attachShader(n,i),t.attachShader(n,s),t.linkProgram(n),t.deleteShader(i),t.deleteShader(s),t.getProgramParameter(n,t.LINK_STATUS))return t.useProgram(n),n;throw new Error(t.getProgramInfoLog(n))}static createVBO(t,i){const s=t.createBuffer();return t.bindBuffer(t.ARRAY_BUFFER,s),t.bufferData(t.ARRAY_BUFFER,new Float32Array(i),t.STATIC_DRAW),t.bindBuffer(t.ARRAY_BUFFER,null),s}static createIBO(t,i){const s=t.createBuffer();return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,s),t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Int16Array(i),t.STATIC_DRAW),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),s}static enableBuffer(t,i,s,n,e){for(let o=0;o<i.length;++o)t.bindBuffer(t.ARRAY_BUFFER,i[o]),t.enableVertexAttribArray(s[o]),t.vertexAttribPointer(s[o],n[o],t.FLOAT,!1,0,0);e!=null&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e)}}class Y{static get Vec2(){return W}static get Vec3(){return Q}static get Mat4(){return $}static get Qtn(){return K}}let W=class _{static create(t=0,i=0){const s=new Float32Array(2);return s[0]=t,s[1]=i,s}static length(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1])}static normalize(t){const i=_.create(),s=_.length(t);if(s>0){const n=1/s;i[0]=t[0]*n,i[1]=t[1]*n}return i}static dot(t,i){return t[0]*i[0]+t[1]*i[1]}static cross(t,i){return _.create(),t[0]*i[1]-t[1]*i[0]}},Q=class G{static create(t=0,i=0,s=0){const n=new Float32Array(3);return n[0]=t,n[1]=i,n[2]=s,n}static length(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}static normalize(t){const i=G.create(),s=G.length(t);if(s>0){const n=1/s;i[0]=t[0]*n,i[1]=t[1]*n,i[2]=t[2]*n}return i}static dot(t,i){return t[0]*i[0]+t[1]*i[1]+t[2]*i[2]}static cross(t,i){return G.create(t[1]*i[2]-t[2]*i[1],t[2]*i[0]-t[0]*i[2],t[0]*i[1]-t[1]*i[0])}static faceNormal(t,i,s){const n=G.create(i[0]-t[0],i[1]-t[1],i[2]-t[2]),e=G.create(s[0]-t[0],s[1]-t[1],s[2]-t[2]),o=G.create(n[1]*e[2]-n[2]*e[1],n[2]*e[0]-n[0]*e[2],n[0]*e[1]-n[1]*e[0]);return G.normalize(o)}},$=class F{static create(){return new Float32Array(16)}static identity(t){const i=t??F.create();return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}static multiply(t,i,s){const n=s??F.create(),e=t[0],o=t[1],r=t[2],h=t[3],u=t[4],a=t[5],l=t[6],c=t[7],f=t[8],d=t[9],p=t[10],g=t[11],m=t[12],P=t[13],L=t[14],E=t[15],y=i[0],x=i[1],M=i[2],I=i[3],A=i[4],b=i[5],D=i[6],v=i[7],w=i[8],T=i[9],R=i[10],C=i[11],V=i[12],N=i[13],H=i[14],k=i[15];return n[0]=y*e+x*u+M*f+I*m,n[1]=y*o+x*a+M*d+I*P,n[2]=y*r+x*l+M*p+I*L,n[3]=y*h+x*c+M*g+I*E,n[4]=A*e+b*u+D*f+v*m,n[5]=A*o+b*a+D*d+v*P,n[6]=A*r+b*l+D*p+v*L,n[7]=A*h+b*c+D*g+v*E,n[8]=w*e+T*u+R*f+C*m,n[9]=w*o+T*a+R*d+C*P,n[10]=w*r+T*l+R*p+C*L,n[11]=w*h+T*c+R*g+C*E,n[12]=V*e+N*u+H*f+k*m,n[13]=V*o+N*a+H*d+k*P,n[14]=V*r+N*l+H*p+k*L,n[15]=V*h+N*c+H*g+k*E,n}static scale(t,i,s){const n=s??F.create();return n[0]=t[0]*i[0],n[1]=t[1]*i[0],n[2]=t[2]*i[0],n[3]=t[3]*i[0],n[4]=t[4]*i[1],n[5]=t[5]*i[1],n[6]=t[6]*i[1],n[7]=t[7]*i[1],n[8]=t[8]*i[2],n[9]=t[9]*i[2],n[10]=t[10]*i[2],n[11]=t[11]*i[2],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],n}static translate(t,i,s){const n=s??F.create();return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[0]*i[0]+t[4]*i[1]+t[8]*i[2]+t[12],n[13]=t[1]*i[0]+t[5]*i[1]+t[9]*i[2]+t[13],n[14]=t[2]*i[0]+t[6]*i[1]+t[10]*i[2]+t[14],n[15]=t[3]*i[0]+t[7]*i[1]+t[11]*i[2]+t[15],n}static rotate(t,i,s,n){let e=n??F.create();const o=Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]);if(!o)return null;let r=s[0],h=s[1],u=s[2];if(o!=1){const N=1/o;r*=N,h*=N,u*=N}const a=Math.sin(i),l=Math.cos(i),c=1-l,f=t[0],d=t[1],p=t[2],g=t[3],m=t[4],P=t[5],L=t[6],E=t[7],y=t[8],x=t[9],M=t[10],I=t[11],A=r*r*c+l,b=h*r*c+u*a,D=u*r*c-h*a,v=r*h*c-u*a,w=h*h*c+l,T=u*h*c+r*a,R=r*u*c+h*a,C=h*u*c-r*a,V=u*u*c+l;return i?t!=e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]):e=t,e[0]=f*A+m*b+y*D,e[1]=d*A+P*b+x*D,e[2]=p*A+L*b+M*D,e[3]=g*A+E*b+I*D,e[4]=f*v+m*w+y*T,e[5]=d*v+P*w+x*T,e[6]=p*v+L*w+M*T,e[7]=g*v+E*w+I*T,e[8]=f*R+m*C+y*V,e[9]=d*R+P*C+x*V,e[10]=p*R+L*C+M*V,e[11]=g*R+E*C+I*V,e}static lookAt(t,i,s,n){const e=n??F.create(),o=t[0],r=t[1],h=t[2],u=i[0],a=i[1],l=i[2],c=s[0],f=s[1],d=s[2];if(o==u&&r==a&&h==l)return F.identity(e);let p,g,m,P,L,E,y,x,M,I;return y=o-u,x=r-a,M=h-l,I=1/Math.sqrt(y*y+x*x+M*M),y*=I,x*=I,M*=I,p=f*M-d*x,g=d*y-c*M,m=c*x-f*y,I=Math.sqrt(p*p+g*g+m*m),I?(I=1/I,p*=I,g*=I,m*=I):(p=0,g=0,m=0),P=x*m-M*g,L=M*p-y*m,E=y*g-x*p,I=Math.sqrt(P*P+L*L+E*E),I?(I=1/I,P*=I,L*=I,E*=I):(P=0,L=0,E=0),e[0]=p,e[1]=P,e[2]=y,e[3]=0,e[4]=g,e[5]=L,e[6]=x,e[7]=0,e[8]=m,e[9]=E,e[10]=M,e[11]=0,e[12]=-(p*o+g*r+m*h),e[13]=-(P*o+L*r+E*h),e[14]=-(y*o+x*r+M*h),e[15]=1,e}static perspective(t,i,s,n,e){const o=e??F.create(),r=s*Math.tan(t*Math.PI/360),u=r*i*2,a=r*2,l=n-s;return o[0]=s*2/u,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=s*2/a,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=-(n+s)/l,o[11]=-1,o[12]=0,o[13]=0,o[14]=-(n*s*2)/l,o[15]=0,o}static ortho(t,i,s,n,e,o,r){const h=r??F.create(),u=i-t,a=s-n,l=o-e;return h[0]=2/u,h[1]=0,h[2]=0,h[3]=0,h[4]=0,h[5]=2/a,h[6]=0,h[7]=0,h[8]=0,h[9]=0,h[10]=-2/l,h[11]=0,h[12]=-(t+i)/u,h[13]=-(s+n)/a,h[14]=-(o+e)/l,h[15]=1,h}static transpose(t,i){const s=i??F.create();return s[0]=t[0],s[1]=t[4],s[2]=t[8],s[3]=t[12],s[4]=t[1],s[5]=t[5],s[6]=t[9],s[7]=t[13],s[8]=t[2],s[9]=t[6],s[10]=t[10],s[11]=t[14],s[12]=t[3],s[13]=t[7],s[14]=t[11],s[15]=t[15],s}static inverse(t,i){const s=i??F.create(),n=t[0],e=t[1],o=t[2],r=t[3],h=t[4],u=t[5],a=t[6],l=t[7],c=t[8],f=t[9],d=t[10],p=t[11],g=t[12],m=t[13],P=t[14],L=t[15],E=n*u-e*h,y=n*a-o*h,x=n*l-r*h,M=e*a-o*u,I=e*l-r*u,A=o*l-r*a,b=c*m-f*g,D=c*P-d*g,v=c*L-p*g,w=f*P-d*m,T=f*L-p*m,R=d*L-p*P,C=1/(E*R-y*T+x*w+M*v-I*D+A*b);return s[0]=(u*R-a*T+l*w)*C,s[1]=(-e*R+o*T-r*w)*C,s[2]=(m*A-P*I+L*M)*C,s[3]=(-f*A+d*I-p*M)*C,s[4]=(-h*R+a*v-l*D)*C,s[5]=(n*R-o*v+r*D)*C,s[6]=(-g*A+P*x-L*y)*C,s[7]=(c*A-d*x+p*y)*C,s[8]=(h*T-u*v+l*b)*C,s[9]=(-n*T+e*v-r*b)*C,s[10]=(g*I-m*x+L*E)*C,s[11]=(-c*I+f*x-p*E)*C,s[12]=(-h*w+u*D-a*b)*C,s[13]=(n*w-e*D+o*b)*C,s[14]=(-g*M+m*y-P*E)*C,s[15]=(c*M-f*y+d*E)*C,s}static toVecIV(t,i){const s=t[0],n=t[1],e=t[2],o=t[3],r=t[4],h=t[5],u=t[6],a=t[7],l=t[8],c=t[9],f=t[10],d=t[11],p=t[12],g=t[13],m=t[14],P=t[15],L=i[0],E=i[1],y=i[2],x=i[3],M=new Float32Array(4);return M[0]=L*s+E*r+y*l+x*p,M[1]=L*n+E*h+y*c+x*g,M[2]=L*e+E*u+y*f+x*m,M[3]=L*o+E*a+y*d+x*P,M}static screenPositionFromMvp(t,i,s,n){const e=s*.5,o=n*.5,r=F.toVecIV(t,[i[0],i[1],i[2],1]);if(r[3]<=0)return[NaN,NaN];r[0]/=r[3],r[1]/=r[3],r[2]/=r[3];const h=W.create();return h[0]=e+r[0]*e,h[1]=o-r[1]*o,h}},K=class z{static create(){return new Float32Array(4)}static identity(t){const i=t??z.create();return i[0]=0,i[1]=0,i[2]=0,i[3]=1,i}static inverse(t,i){const s=i??z.create();return s[0]=-t[0],s[1]=-t[1],s[2]=-t[2],s[3]=t[3],s}static normalize(t){const i=z.create(),s=t[0],n=t[1],e=t[2],o=Math.sqrt(s*s+n*n+e*e);if(o>0){const r=1/o;i[0]=s*r,i[1]=n*r,i[2]=e*r}return i}static multiply(t,i,s){const n=s??z.create(),e=t[0],o=t[1],r=t[2],h=t[3],u=i[0],a=i[1],l=i[2],c=i[3];return n[0]=e*c+h*u+o*l-r*a,n[1]=o*c+h*a+r*u-e*l,n[2]=r*c+h*l+e*a-o*u,n[3]=h*c-e*u-o*a-r*l,n}static rotate(t,i,s){const n=s??z.create();let e=i[0],o=i[1],r=i[2];const h=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]);if(h!==0){const a=1/h;e*=a,o*=a,r*=a}const u=Math.sin(t*.5);return n[0]=e*u,n[1]=o*u,n[2]=r*u,n[3]=Math.cos(t*.5),n}static toVecIII(t,i,s){const n=s??Q.create(),e=z.create(),o=z.create(),r=z.create();return z.inverse(i,r),e[0]=t[0],e[1]=t[1],e[2]=t[2],z.multiply(r,e,o),z.multiply(o,i,r),n[0]=r[0],n[1]=r[1],n[2]=r[2],n}static toMatIV(t,i){const s=i??$.create(),n=t[0],e=t[1],o=t[2],r=t[3],h=n+n,u=e+e,a=o+o,l=n*h,c=n*u,f=n*a,d=e*u,p=e*a,g=o*a,m=r*h,P=r*u,L=r*a;return s[0]=1-(d+g),s[1]=c-L,s[2]=f+P,s[3]=0,s[4]=c+L,s[5]=1-(l+g),s[6]=p-m,s[7]=0,s[8]=f-P,s[9]=p+m,s[10]=1-(l+d),s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,s}static slerp(t,i,s,n){const e=n??z.create(),o=t[0]*i[0]+t[1]*i[1]+t[2]*i[2]+t[3]*i[3];let r=1-o*o;if(r<=0)e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3];else if(r=Math.sqrt(r),Math.abs(r)<1e-4)e[0]=t[0]*.5+i[0]*.5,e[1]=t[1]*.5+i[1]*.5,e[2]=t[2]*.5+i[2]*.5,e[3]=t[3]*.5+i[3]*.5;else{const h=Math.acos(o),u=h*s,a=Math.sin(h-u)/r,l=Math.sin(u)/r;e[0]=t[0]*a+i[0]*l,e[1]=t[1]*a+i[1]*l,e[2]=t[2]*a+i[2]*l,e[3]=t[3]*a+i[3]*l}return e}};class J{static plane(t,i,s){const n=t/2,e=i/2,o=[-n,e,0,n,e,0,-n,-e,0,n,-e,0],r=[0,0,1,0,0,1,0,0,1,0,0,1],h=[s[0],s[1],s[2],s[3],s[0],s[1],s[2],s[3],s[0],s[1],s[2],s[3],s[0],s[1],s[2],s[3]];return{position:o,normal:r,color:h,texCoord:[0,0,1,0,0,1,1,1],index:[0,2,1,1,2,3]}}static circle(t,i,s){const n=[],e=[],o=[],r=[],h=[];n.push(0,0,0),e.push(0,0,1),o.push(s[0],s[1],s[2],s[3]),r.push(.5,.5);let u=0;for(let a=0;a<t;a++){const l=Math.PI*2/t*a,c=Math.cos(l),f=Math.sin(l);n.push(c*i,f*i,0),e.push(0,0,1),o.push(s[0],s[1],s[2],s[3]),r.push((c+1)*.5,1-(f+1)*.5),a===t-1?h.push(0,u+1,1):h.push(0,u+1,u+2),++u}return{position:n,normal:e,color:o,texCoord:r,index:h}}static cube(t,i){const s=t*.5,n=[-s,-s,s,s,-s,s,s,s,s,-s,s,s,-s,-s,-s,-s,s,-s,s,s,-s,s,-s,-s,-s,s,-s,-s,s,s,s,s,s,s,s,-s,-s,-s,-s,s,-s,-s,s,-s,s,-s,-s,s,s,-s,-s,s,s,-s,s,s,s,s,-s,s,-s,-s,-s,-s,-s,s,-s,s,s,-s,s,-s],e=1/Math.sqrt(3),o=[-e,-e,e,e,-e,e,e,e,e,-e,e,e,-e,-e,-e,-e,e,-e,e,e,-e,e,-e,-e,-e,e,-e,-e,e,e,e,e,e,e,e,-e,-e,-e,-e,e,-e,-e,e,-e,e,-e,-e,e,e,-e,-e,e,e,-e,e,e,e,e,-e,e,-e,-e,-e,-e,-e,e,-e,e,e,-e,e,-e],r=[];for(let a=0;a<n.length/3;a++)r.push(i[0],i[1],i[2],i[3]);return{position:n,normal:o,color:r,texCoord:[0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1],index:[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]}}static cone(t,i,s,n){const e=[],o=[],r=[],h=[],u=[],a=s/2;e.push(0,-a,0),o.push(0,-1,0),r.push(n[0],n[1],n[2],n[3]),h.push(.5,.5);let l=0;for(let c=0;c<=t;c++){const f=Math.PI*2/t*c,d=Math.cos(f),p=Math.sin(f);e.push(d*i,-a,p*i,d*i,-a,p*i),o.push(0,-1,0,d,0,p),r.push(n[0],n[1],n[2],n[3],n[0],n[1],n[2],n[3]),h.push((d+1)*.5,1-(p+1)*.5,(d+1)*.5,1-(p+1)*.5),c!==t&&(u.push(0,l+1,l+3),u.push(l+4,l+2,t*2+3)),l+=2}return e.push(0,a,0),o.push(0,1,0),r.push(n[0],n[1],n[2],n[3]),h.push(.5,.5),{position:e,normal:o,color:r,texCoord:h,index:u}}static cylinder(t,i,s,n,e){const o=[],r=[],h=[],u=[],a=[],l=n/2;o.push(0,l,0,0,-l,0),r.push(0,1,0,0,-1,0),h.push(e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3]),u.push(.5,.5,.5,.5);let c=2;for(let f=0;f<=t;f++){const d=Math.PI*2/t*f,p=Math.cos(d),g=Math.sin(d);o.push(p*i,l,g*i,p*i,l,g*i,p*s,-l,g*s,p*s,-l,g*s),r.push(0,1,0,p,0,g,0,-1,0,p,0,g),h.push(e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3]),u.push((p+1)*.5,1-(g+1)*.5,1-f/t,0,(p+1)*.5,1-(g+1)*.5,1-f/t,1),f!==t&&a.push(0,c+4,c,1,c+2,c+6,c+5,c+7,c+1,c+1,c+7,c+3),c+=4}return{position:o,normal:r,color:h,texCoord:u,index:a}}static sphere(t,i,s,n){const e=[],o=[],r=[],h=[],u=[];for(let a=0;a<=t;a++){const l=Math.PI/t*a,c=Math.cos(l),f=Math.sin(l);for(let d=0;d<=i;d++){const p=Math.PI*2/i*d,g=f*s*Math.cos(p),m=c*s,P=f*s*Math.sin(p),L=f*Math.cos(p),E=f*Math.sin(p);e.push(g,m,P),o.push(L,c,E),r.push(n[0],n[1],n[2],n[3]),h.push(1-1/i*d,1/t*a)}}for(let a=0;a<t;a++)for(let l=0;l<i;l++){const c=(i+1)*a+l;u.push(c,c+1,c+i+2),u.push(c,c+i+2,c+i+1)}return{position:e,normal:o,color:r,texCoord:h,index:u}}static torus(t,i,s,n,e){const o=[],r=[],h=[],u=[],a=[];for(let l=0;l<=t;l++){const c=Math.PI*2/t*l,f=Math.cos(c),d=Math.sin(c);for(let p=0;p<=i;p++){const g=Math.PI*2/i*p,m=(f*s+n)*Math.cos(g),P=d*s,L=(f*s+n)*Math.sin(g),E=f*Math.cos(g),y=f*Math.sin(g),x=1/i*p;let M=1/t*l+.5;M>1&&(M-=1),M=1-M,o.push(m,P,L),r.push(E,d,y),h.push(e[0],e[1],e[2],e[3]),u.push(x,M)}}for(let l=0;l<t;l++)for(let c=0;c<i;c++){const f=(i+1)*l+c;a.push(f,f+i+1,f+1),a.push(f+i+1,f+i+2,f+1)}return{position:o,normal:r,color:h,texCoord:u,index:a}}static icosahedron(t,i){const s=(1+Math.sqrt(5))/2,n=s*t,e=Math.sqrt(1+s*s),o=[1/e,s/e],r=[-t,n,0,t,n,0,-t,-n,0,t,-n,0,0,-t,n,0,t,n,0,-t,-n,0,t,-n,n,0,-t,n,0,t,-n,0,-t,-n,0,t],h=[-o[0],o[1],0,o[0],o[1],0,-o[0],-o[1],0,o[0],-o[1],0,0,-o[0],o[1],0,o[0],o[1],0,-o[0],-o[1],0,o[0],-o[1],o[1],0,-o[0],o[1],0,o[0],-o[1],0,-o[0],-o[1],0,o[0]],u=[i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3]],a=[];for(let c=0,f=h.length;c<f;c+=3){const d=(Math.atan2(h[c+2],-h[c])+Math.PI)/(Math.PI*2),p=1-(h[c+1]+1)/2;a.push(d,p)}return{position:r,normal:h,color:u,texCoord:a,index:[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}}}const X=Y.Vec2,B=Y.Vec3,q=Y.Mat4,S=Y.Qtn;class j{static get DEFAULT_DISTANCE(){return 5}static get DEFAULT_MIN_DISTANCE(){return 1}static get DEFAULT_MAX_DISTANCE(){return 10}static get DEFAULT_MOVE_SCALE(){return 2}constructor(t,i={}){this.target=t,this.distance=i.distance||j.DEFAULT_DISTANCE,this.minDistance=i.min||j.DEFAULT_MIN_DISTANCE,this.maxDistance=i.max||j.DEFAULT_MAX_DISTANCE,this.moveScale=i.move||j.DEFAULT_MOVE_SCALE,this.position=B.create(0,0,this.distance),this.center=B.create(0,0,0),this.upDirection=B.create(0,1,0),this.defaultPosition=B.create(0,0,this.distance),this.defaultCenter=B.create(0,0,0),this.defaultUpDirection=B.create(0,1,0),this.movePosition=B.create(0,0,0),this.rotateX=0,this.rotateY=0,this.scale=0,this.isDown=!1,this.prevPosition=X.create(0,0),this.offsetPosition=X.create(0,0),this.qt=S.create(),this.qtx=S.create(),this.qty=S.create(),this.mouseInteractionStart=this.mouseInteractionStart.bind(this),this.mouseInteractionMove=this.mouseInteractionMove.bind(this),this.mouseInteractionEnd=this.mouseInteractionEnd.bind(this),this.wheelScroll=this.wheelScroll.bind(this),this.target.addEventListener("mousedown",this.mouseInteractionStart,!1),this.target.addEventListener("mousemove",this.mouseInteractionMove,!1),this.target.addEventListener("mouseup",this.mouseInteractionEnd,!1),this.target.addEventListener("wheel",this.wheelScroll,!1),this.target.addEventListener("contextmenu",s=>{s.preventDefault()},!1)}setPosition(t){this.defaultPosition=t}mouseInteractionStart(t){this.isDown=!0;const i=this.target.getBoundingClientRect();this.prevPosition=X.create(t.clientX-i.left,t.clientY-i.top)}mouseInteractionMove(t){if(this.isDown!==!0)return;const i=this.target.getBoundingClientRect(),s=i.width,n=i.height,e=t.clientX-i.left,o=t.clientY-i.top,r=1/Math.min(s,n);switch(this.offsetPosition=X.create(e-this.prevPosition[0],o-this.prevPosition[1]),this.prevPosition=X.create(e,o),t.buttons){case 1:this.rotateX+=this.offsetPosition[0]*r,this.rotateY+=this.offsetPosition[1]*r,this.rotateX=this.rotateX%1,this.rotateY=Math.min(Math.max(this.rotateY%1,-.25),.25);break;case 2:const h=B.create(this.offsetPosition[0],-this.offsetPosition[1],0),u=S.toVecIII(h,this.qt);this.movePosition[0]-=u[0]*r*this.moveScale,this.movePosition[1]-=u[1]*r*this.moveScale,this.movePosition[2]-=u[2]*r*this.moveScale;break}}mouseInteractionEnd(t){this.isDown=!1}wheelScroll(t){const i=t.wheelDelta;i>0?this.scale=-.5:i<0&&(this.scale=.5)}update(){const t=Math.PI*2,i=B.create(1,0,0),s=B.create(0,1,0);return this.scale*=.7,this.distance+=this.scale,this.distance=Math.min(Math.max(this.distance,this.minDistance),this.maxDistance),this.defaultPosition[2]=this.distance,S.identity(this.qt),S.identity(this.qtx),S.identity(this.qty),S.rotate(this.rotateX*t,s,this.qtx),S.toVecIII(i,this.qtx,i),S.rotate(this.rotateY*t,i,this.qty),S.multiply(this.qtx,this.qty,this.qt),S.toVecIII(this.defaultPosition,this.qt,this.position),S.toVecIII(this.defaultUpDirection,this.qt,this.upDirection),this.position[0]+=this.movePosition[0],this.position[1]+=this.movePosition[1],this.position[2]+=this.movePosition[2],this.center[0]=this.defaultCenter[0]+this.movePosition[0],this.center[1]=this.defaultCenter[1]+this.movePosition[1],this.center[2]=this.defaultCenter[2]+this.movePosition[2],q.lookAt(this.position,this.center,this.upDirection)}}var tt=`attribute vec3 position;
attribute vec3 normal;
attribute vec4 color;
uniform mat4 mvpMatrix;
varying vec4 vColor;
varying vec3 vNormal;
varying vec3 vPosition;

void main(){
    vNormal = normal;
    vPosition = position;

    vColor = color;

    gl_Position = mvpMatrix * vec4(position, 1.0);
}`,it=`precision mediump float;

uniform float intensity;
uniform vec3 pointLightPosition1;

uniform float isDirectionalLight;
uniform vec3 directionalLightColor;
uniform vec3 pointLightColor1;
uniform vec3 spotLightPosition;
uniform vec3 spotLightTarget;
uniform vec3 spotLightColor;
uniform float innerLimit;
uniform float outerLimit;
uniform mat4 normalMatrix;

varying vec4 vColor;
varying vec3 vNormal;
varying vec3 vPosition;

const vec3 light = vec3(1.0, 1.0, 1.0);

void main() {
    vec3 n = (normalMatrix * vec4(vNormal, 0.0)).xyz;
    float d = dot(normalize(n), normalize(light));

    vec3 pointLightDirection = pointLightPosition1 - vPosition;
    float pd = clamp(dot(normalize(n), normalize(pointLightDirection)), 0.0, 1.0);

    vec3 spotLightDirection = spotLightPosition - vPosition;
    vec3 spotDirection = spotLightTarget - spotLightPosition;
    float spotEffect = dot(normalize(spotLightDirection), normalize(-spotDirection));
    float inLight = smoothstep(outerLimit, innerLimit, spotEffect);
    float sd = inLight * clamp(dot(normalize(n), normalize(spotLightDirection)), 0.0, 1.0);

    float isAmbient = step(1.0, isDirectionalLight);
    vec3 ambient = isAmbient * vec3(0.1, 0.1, 0.1);

    vec3 combinedLight = d * directionalLightColor * intensity + pd * pointLightColor1 + sd * spotLightColor + ambient;

    gl_FragColor = vec4(vColor.rgb * combinedLight, vColor.a);
}`;window.addEventListener("DOMContentLoaded",()=>{const U=new st;U.init(),U.load().then(()=>{U.setupGeometry(),U.setupLocation(),U.start()})},!1);class st{constructor(){this.canvas=null,this.gl=null,this.program=null,this.attributeLocation=null,this.attributeStride=null,this.uniformLocation=null,this.torusGeometry=null,this.torusVBO=null,this.torusIBO=null,this.sphereGeometry=null,this.sphereVBO=null,this.sphereIBO=null,this.startTime=null,this.camera=null,this.isRender=!1,this.isTorusRotation=!1,this.isDirectionalLight=!0,this.directionalLightColor=[1,1,1],this.intensity=.5,this.isPointLight1=!1,this.isPointLightRotation1=!1,this.pointLightColor1=[1,0,0],this.isSpotLight=!1,this.isSpotLightTargetRotation=!1,this.spotLightPosition={x:0,y:2,z:0},this.spotLightColor=[0,0,1],this.innerLimit=10,this.outerLimit=20,this.resize=this.resize.bind(this),this.render=this.render.bind(this)}setCulling(t){const i=this.gl;i!=null&&(t===!0?i.enable(i.CULL_FACE):i.disable(i.CULL_FACE))}setDepthTest(t){const i=this.gl;i!=null&&(t===!0?i.enable(i.DEPTH_TEST):i.disable(i.DEPTH_TEST))}setRotation(t){this.isTorusRotation=t}init(){this.canvas=document.getElementById("webgl-canvas"),this.gl=O.createWebGLContext(this.canvas);const t=Y.Vec3,i={distance:4,min:1,max:10,move:2};this.camera=new j(this.canvas,i),this.camera.setPosition(t.create(0,3,i.distance)),this.resize(),window.addEventListener("resize",this.resize,!1),this.gl.enable(this.gl.CULL_FACE),this.gl.enable(this.gl.DEPTH_TEST);const s=new Z;s.add(this,"isTorusRotation").name("Rotation");const n=s.addFolder("Directional Light");n.add(this,"isDirectionalLight").name("On/Off").onChange(r=>{r?this.intensity=.5:this.intensity=0}),n.addColor(this,"directionalLightColor").name("Color"),n.add(this,"intensity",0,1).name("Intensity").onChange(r=>{this.isDirectionalLight?this.intensity=r:this.intensity=0});const e=s.addFolder("Point Light");e.add(this,"isPointLight1").name("On/Off"),e.add(this,"isPointLightRotation1").name("Rotation");const o=s.addFolder("Spot Light");o.add(this,"isSpotLight").name("On/Off"),o.add(this,"isSpotLightTargetRotation").name("Rotation"),o.add(this,"innerLimit",1,90),o.add(this,"outerLimit",1,90)}resize(){this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight}load(){return new Promise((t,i)=>{const s=this.gl;if(s==null){const n=new Error("not initialized");i(n)}else{let n=O.createShaderObject(s,tt,s.VERTEX_SHADER),e=O.createShaderObject(s,it,s.FRAGMENT_SHADER);this.program=O.createProgramObject(s,n,e),t()}})}setupGeometry(){const e=[1,1,1,1];this.torusGeometry=J.torus(32,32,.4,.8,e),this.torusVBO=[O.createVBO(this.gl,this.torusGeometry.position),O.createVBO(this.gl,this.torusGeometry.normal),O.createVBO(this.gl,this.torusGeometry.color)],this.torusIBO=O.createIBO(this.gl,this.torusGeometry.index)}setupLocation(){const t=this.gl;this.attributeLocation=[t.getAttribLocation(this.program,"position"),t.getAttribLocation(this.program,"normal"),t.getAttribLocation(this.program,"color")],this.attributeStride=[3,3,4],this.uniformLocation={mvpMatrix:t.getUniformLocation(this.program,"mvpMatrix"),normalMatrix:t.getUniformLocation(this.program,"normalMatrix"),isDirectionalLight:t.getUniformLocation(this.program,"this.isDirectionalLight"),pointLightPosition1:t.getUniformLocation(this.program,"pointLightPosition1"),intensity:t.getUniformLocation(this.program,"intensity"),pointLightPosition2:t.getUniformLocation(this.program,"pointLightPosition2"),spotLightPosition:t.getUniformLocation(this.program,"spotLightPosition"),spotLightTarget:t.getUniformLocation(this.program,"spotLightTarget"),directionalLightColor:t.getUniformLocation(this.program,"directionalLightColor"),pointLightColor1:t.getUniformLocation(this.program,"pointLightColor1"),spotLightColor:t.getUniformLocation(this.program,"spotLightColor"),innerLimit:t.getUniformLocation(this.program,"innerLimit"),outerLimit:t.getUniformLocation(this.program,"outerLimit")}}setupRendering(){const t=this.gl;t.viewport(0,0,this.canvas.width,this.canvas.height),t.clearColor(0,0,0,1),t.clearDepth(1),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT)}start(){this.startTime=Date.now(),this.isRender=!0,this.render()}stop(){this.isRender=!1}render(){const t=this.gl,i=Y.Mat4,s=Y.Vec3;this.isRender===!0&&requestAnimationFrame(this.render),this.isPointLight1?this.pointLightColor1=[1,0,0]:this.pointLightColor1=[0,0,0],this.isSpotLight?this.spotLightColor=[0,0,1]:this.spotLightColor=[0,0,0];const n=(Date.now()-this.startTime)*.001;this.setupRendering();const e=s.create(0,1,0),o=this.isTorusRotation===!0?i.rotate(i.identity(),n,e):i.identity(),r=this.camera.update(),h=45,u=window.innerWidth/window.innerHeight,a=.1,l=10,c=i.perspective(h,u,a,l),f=i.multiply(c,r),d=i.multiply(f,o),p=i.transpose(i.inverse(o)),g=this.isPointLightRotation1?s.create(Math.sin(n)*2,Math.cos(n)*2,1):s.create(2,2,1),m=s.create(this.spotLightPosition.x,this.spotLightPosition.y,this.spotLightPosition.z),P=this.isSpotLightTargetRotation?s.create(Math.cos(n),0,Math.sin(n)):s.create(1,0,0),L=this.innerLimit*Math.PI/180,E=this.outerLimit*Math.PI/180,y=this.isDirectionalLight?1:0;t.useProgram(this.program),t.uniformMatrix4fv(this.uniformLocation.mvpMatrix,!1,d),t.uniformMatrix4fv(this.uniformLocation.normalMatrix,!1,p),t.uniform1f(this.uniformLocation.isDirectionalLight,y),t.uniform1f(this.uniformLocation.intensity,this.intensity),t.uniform3fv(this.uniformLocation.pointLightPosition1,g),t.uniform3fv(this.uniformLocation.spotLightPosition,m),t.uniform3fv(this.uniformLocation.spotLightTarget,P),t.uniform3fv(this.uniformLocation.directionalLightColor,this.directionalLightColor),t.uniform3fv(this.uniformLocation.pointLightColor1,this.pointLightColor1),t.uniform3fv(this.uniformLocation.spotLightColor,this.spotLightColor),t.uniform1f(this.uniformLocation.innerLimit,Math.cos(L)),t.uniform1f(this.uniformLocation.outerLimit,Math.cos(E)),O.enableBuffer(t,this.torusVBO,this.attributeLocation,this.attributeStride,this.torusIBO),t.drawElements(t.TRIANGLES,this.torusGeometry.index.length,t.UNSIGNED_SHORT,0)}}
